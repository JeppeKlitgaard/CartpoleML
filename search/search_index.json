{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 CartER [ Cartpole Environment for Reinforcement learning ] is an open-source learning platform that enables the user to quickly start experimenting with simulated and physical multi-agent reinforcement learning projects quickly. CartER is still being actively developed and uses state-of-the-art reinforcement-learning libraries for greater reproducibility. Author \u00b6 The CartER project is an undergraduate research project undertaken by Jeppe Klitgaard at the Biological and Soft Systems group at Cavendish Laboratory, University of Cambridge under supervision of Professor Pietro Cicuta and Professor Pietro Lio. Queries can be made to jk782@cam.ac.uk or through the GitHub repository located at JeppeKlitgaard/CartER Citation \u00b6 CartER can be cited in publications using: @misc{carter, author = {Jeppe Klitgaard, Pietro Cicuta, Pietro Lio}, title = {CartER}, year = {2021}, publisher = {GitHub}, journal = {GitHub repository}, howpublished = {\\url{https://github.com/JeppeKlitgaard/CartER}}, } Documentation overview \u00b6 The documentation is incomplete and should not be taken as gospel. It is divided into a number of categories: Development : Documentation surrounding the development of the project. Useful for advanced use or further development of the platform. Building : Documentation on acquiring hardware, 3D-printing parts, and assemblying the project. Usage : Guides on how to use the platform for machine learning. Articles : A collection of articles related to the project. Videos : A collection of videos of the project in action. Project overview \u00b6 The project consists of two main components: Commander : The Python-based codebase that runs simulations, does both learning and inference, and communicates with the Controller using a low-level networking protocol Controller : The C/C++ based codebase that runs on Arduino SAM-based (32-bit ARM) microprocessors (namely the Arduino Due). The Controller handles sensors, motors, and communicating with the Commander over a serial interface. Underlying technologies \u00b6 CartER uses the following underlying technologies. Commander \u00b6 poetry : Project and package management stable_baselines3 : pytorch -based standard implementations of common model-free reinforcement learning algorithms tensorboard : For studying parameters and other output from the experiments pettingzoo : Standardising the multi-agent environment Controller \u00b6 platformio : Framework for embedded programming","title":"Introduction"},{"location":"#introduction","text":"CartER [ Cartpole Environment for Reinforcement learning ] is an open-source learning platform that enables the user to quickly start experimenting with simulated and physical multi-agent reinforcement learning projects quickly. CartER is still being actively developed and uses state-of-the-art reinforcement-learning libraries for greater reproducibility.","title":"Introduction"},{"location":"#author","text":"The CartER project is an undergraduate research project undertaken by Jeppe Klitgaard at the Biological and Soft Systems group at Cavendish Laboratory, University of Cambridge under supervision of Professor Pietro Cicuta and Professor Pietro Lio. Queries can be made to jk782@cam.ac.uk or through the GitHub repository located at JeppeKlitgaard/CartER","title":"Author"},{"location":"#citation","text":"CartER can be cited in publications using: @misc{carter, author = {Jeppe Klitgaard, Pietro Cicuta, Pietro Lio}, title = {CartER}, year = {2021}, publisher = {GitHub}, journal = {GitHub repository}, howpublished = {\\url{https://github.com/JeppeKlitgaard/CartER}}, }","title":"Citation"},{"location":"#documentation-overview","text":"The documentation is incomplete and should not be taken as gospel. It is divided into a number of categories: Development : Documentation surrounding the development of the project. Useful for advanced use or further development of the platform. Building : Documentation on acquiring hardware, 3D-printing parts, and assemblying the project. Usage : Guides on how to use the platform for machine learning. Articles : A collection of articles related to the project. Videos : A collection of videos of the project in action.","title":"Documentation overview"},{"location":"#project-overview","text":"The project consists of two main components: Commander : The Python-based codebase that runs simulations, does both learning and inference, and communicates with the Controller using a low-level networking protocol Controller : The C/C++ based codebase that runs on Arduino SAM-based (32-bit ARM) microprocessors (namely the Arduino Due). The Controller handles sensors, motors, and communicating with the Commander over a serial interface.","title":"Project overview"},{"location":"#underlying-technologies","text":"CartER uses the following underlying technologies.","title":"Underlying technologies"},{"location":"#commander","text":"poetry : Project and package management stable_baselines3 : pytorch -based standard implementations of common model-free reinforcement learning algorithms tensorboard : For studying parameters and other output from the experiments pettingzoo : Standardising the multi-agent environment","title":"Commander"},{"location":"#controller","text":"platformio : Framework for embedded programming","title":"Controller"},{"location":"articles/","text":"Introduction \u00b6 Here you will find articles related to the project. These are generally not written in the formal style of an academic paper, but rather in the style one might find on Medium or Jekyll blogs.","title":"Introduction"},{"location":"articles/#introduction","text":"Here you will find articles related to the project. These are generally not written in the formal style of an academic paper, but rather in the style one might find on Medium or Jekyll blogs.","title":"Introduction"},{"location":"articles/handover_v1/","text":"Handover from 10 week internship \u00b6 This document describes the handover of the project after my (Jeppe Klitgaard) 10 week internship. Last minute change Before I went home on 2021-09-03 (last day) I got an epiphany that some of the weird error behaviour I have been experiencing in the last few days originates from noise from the stepper motor wires. I have cut some of the cable management zip ties and rearranged the wires to reduce this effect, as well as disconnected the screw mounting block for the rotary encoders. If it does turn out that this has fixed the issue, the cables for the steppers will need to be rerouted to reduce noise transmission after which point the cable management and the rotary encoders should be able to be reinstated without issue. It is possible that the noise has damaged some pins or parts of the Arduino Due, in which case the Due would need to be replaced. This seems unlikely, however. Jeppe What works \u00b6 Commander: Simulated Environment (Implemented as a PettingZoo -style ParallelEnv ) Commander: Experimental Environment (Implemented as a PettingZoo -style ParallelEnv ) Commander: Various CLI tools and utilities Commander: Networking protocol (serial-over-USB based, binary protocol using CPP POD's) Commander: Tensorboard integration with many diagonsitic metrics Commander: Profiling utility ( yappi -based) Commander: Unified Simulation/Experiment CLI interface for running experiments Commander: Thorough logging for easier debugging Commander: Code is compliant with: mypy (strict) , black , flake8 , and isort . Commander: Code requires Python 3.9+ Commander: GPU (CUDA) integrated ML Commander: PPO model (from stable-baselines3 ) Commander: A2C model (from stable-baselines3 ) Controller: Networking protocol Controller: Interrupt-based stepping Controller: Limit finding and checking Controller: Pendulum jiggling Controller: Checks for angle and position wander during episode (logged in Tensorboard) Controller: Lossy network stream realignment Controller: High-level logic controllable over serial Hardware: The whole 3D printed setup Hardware: Steppers Hardware: Stepper drivers Hardware: 115200 baud Serial-over-USB Hardware: Belt tensioning system What does not work \u00b6 Rotary encoders \u00b6 The rotary encoders have been acting very weird in the last few days. They are now disabled when the FakeRotaryEncoders flag is true , which has solved intermittent blocking and crashes. The crashes did not occur consistently or even at a particular point in the code. Sometimes the Arduino would randomly not exit the jiggling loop, for example. This is incredibly odd, as no I2C logic is run during that loop, nor by the stepping interrupt. Perhaps the rotary encoder chip is bad and causes undefined behaviour on the Arduino due to not acting as a nice I2C slave. Perhaps the Arduino has somehow been damaged, though hopefully this would not cause such inconsistent, intermittent failures. This may also be tangentially related to the fact that the rotary encoder does not experience a magnetic field of ideal strength. This is due to the proximity of the diametrically magnetised coin magnet to the ferromagnetic ball bearing. This distance should be increased in a later hardware revision (very easy and unintrusive, just didn't have the time). This, however, should also not result in the behaviour I saw. It is also possible that this stems from a bug in the code of the rotary encoder library (AMS_5600), which I did not fully investigate. It could also be due to an error in the I2C multiplexer used. Since the Due has two I2C interfaces, the multiplexer is not strictly needed, though some modification of the AMS_5600 library would be needed to use both I2C interfaces. Random Arduino Resets \u00b6 I am getting random Arduino resets and I cannot for the life of me figure out why. The latest theory is that the noise from the wires going to the stepper motors is causing overvoltages on some logic lines that will then trigger a reset. This could be tested by disabling the motor power supply and running the experiment for a few hours. If no resets occur, it is likely a problem related to electrical noise. I haven't had time to try this, so please go ahead and try. It is some very long hanging fruit! Learning on the physical system \u00b6 I have not yet been able to get significant learning using the experimental setup. I believe as of today (my last day), the experiment will now run for extended periods of time (after disabling the rotary encoders), and so it may learn over the coming weekend. It could also be that the PPO/A2C algorithms used are not pleased with the inconsistent step intervals (these arise from learning causing the thread to block for tens of millisecs, as well as delays in the USB protocol and on the host computer). From Tensorboard it is clear that the correct rewards are being calculated and actions are being taken, though these do not seem to lead to improved behaviour over time - perhaps I simply haven't given it enough time yet. I don't have any obvious explanations for why the learning is not better than it currently is. I may have missed a critical bug somewhere, but since rewards and actions are both working as expected, I don't think this will be the case. Perhaps model-free reinforcement learning is just very difficult, particularly on noisy, physical systems? It could also be that the hyperparameters need significant tuning in order to get stable learning to occur. Two-carriage configuration \u00b6 Most of the code is set up to handle two carriages already, though currently the limit finding/checking routines would need to be updated to work for a two-carriage system as well. The hardware and electronics are fully compatible with both a one- and two-carriage configuration. Likely there is also some code on the environment (not agent) level in the Commander that would need fine-tuning. The two-carriage configuration should only be persued once the one-carriage configuration is fully working and finalised. What could be improved \u00b6 New Microcontroller \u00b6 Dealing with the Arduino Due has been somewhat frustrating, and while changing to a different one at this stage would require some effort, I believe that it would be worth it. Problematically the Arduino Due has not seen significant work done on it's core software in many years and the documentation for the board is even poorer than the already poor documentation for 8-bit AVR Arduino boards. I changed away from the Arduino build system fairly early on after getting frustrated with the terrible usability problems of it as well as its practically non-existant support for multiple files. Instead, the project now uses platform.io , which is orders of magnitude more reliable, intuitive, and well-designed. Ultimately, I think the same should be done for the Arduino. Since CartER aims to be easy to set up for others and should rely on off-the-shelf parts, I think the STM Nucleo-144 could be a very powerful option: Built-in debugger 400 MHz clock speed Ethernet support Higher baudrates possible (limited to 115200 on Due due to bug in Arduino Core\ud83d\ude1e) Many pins broken out Cheap Readily available mbed -compatible When doing this, it would be very worthwhile to switch away from the Arduino Wiring framework entirely, as this is incredibly poorly documented and only ever intended for hobbyist use. Arduino was groundbreaking in that it made access to hobby-level microcontrollers easy and open, but since then Arm has developed mbed which is also open and is infinitely more polished. mbed even has a full RTOS version, which could be very useful for this project. This would likely make it possible to reduce fiddliness around the I2C connection with the rotary encoder, as well as a generally nicer code layout. mbed + STM Nucleo-144 is supported in platform.io . There is an existing library for modern TMC stepper drivers for mbed and writing a quick library for the rotary encoder should not take long. New stepper drivers \u00b6 Rather than relying on the rather old TMC26X drivers, these should be changed for TMC2208/TMC2209 drivers. These have far better support and documentation. They are cheap and more readily available than the TMC26X drivers, which are strictly inferior. Real-time (or close to it) Networking \u00b6 Using Serial-over-USB is far from ideal and seems to give a 4ms round-trip time in the best of cases (See: Serial ). Since the STM board has Ethernet capability built in, it might be useful to use Ethernet for networking. This would allow far lower latency and much more reliable communication than the current implementation. A real-time ethernet system like EtherCAT could be used if timing becomes critical, though this will likely be overkill. Alternatively a proper serial connection could be used. This would require a simple level-shifting board on the controller-side and a serial board to be installed in the computer. Both of these options are cheap and readily available. Arguably Ethernet is more commonly found, though configuration can also be more complicated. Getting set up \u00b6 A good way of working is using VSCode with the Remote: SSH functionality. That way, you get to develop on the powerful workstation and run experiments and simulations on it directly, but while still using your own IDE configuration and the familiar keyboard of your laptop. These lines, for example, were written in the rest area upstairs, but on the workstation downstairs in the Physics Lab through seamless integration via SSH and VSCode. More advice on how to get set up can be found in the other sections of the documentation.","title":"Handover from 10 week internship"},{"location":"articles/handover_v1/#handover-from-10-week-internship","text":"This document describes the handover of the project after my (Jeppe Klitgaard) 10 week internship. Last minute change Before I went home on 2021-09-03 (last day) I got an epiphany that some of the weird error behaviour I have been experiencing in the last few days originates from noise from the stepper motor wires. I have cut some of the cable management zip ties and rearranged the wires to reduce this effect, as well as disconnected the screw mounting block for the rotary encoders. If it does turn out that this has fixed the issue, the cables for the steppers will need to be rerouted to reduce noise transmission after which point the cable management and the rotary encoders should be able to be reinstated without issue. It is possible that the noise has damaged some pins or parts of the Arduino Due, in which case the Due would need to be replaced. This seems unlikely, however. Jeppe","title":"Handover from 10 week internship"},{"location":"articles/handover_v1/#what-works","text":"Commander: Simulated Environment (Implemented as a PettingZoo -style ParallelEnv ) Commander: Experimental Environment (Implemented as a PettingZoo -style ParallelEnv ) Commander: Various CLI tools and utilities Commander: Networking protocol (serial-over-USB based, binary protocol using CPP POD's) Commander: Tensorboard integration with many diagonsitic metrics Commander: Profiling utility ( yappi -based) Commander: Unified Simulation/Experiment CLI interface for running experiments Commander: Thorough logging for easier debugging Commander: Code is compliant with: mypy (strict) , black , flake8 , and isort . Commander: Code requires Python 3.9+ Commander: GPU (CUDA) integrated ML Commander: PPO model (from stable-baselines3 ) Commander: A2C model (from stable-baselines3 ) Controller: Networking protocol Controller: Interrupt-based stepping Controller: Limit finding and checking Controller: Pendulum jiggling Controller: Checks for angle and position wander during episode (logged in Tensorboard) Controller: Lossy network stream realignment Controller: High-level logic controllable over serial Hardware: The whole 3D printed setup Hardware: Steppers Hardware: Stepper drivers Hardware: 115200 baud Serial-over-USB Hardware: Belt tensioning system","title":"What works"},{"location":"articles/handover_v1/#what-does-not-work","text":"","title":"What does not work"},{"location":"articles/handover_v1/#rotary-encoders","text":"The rotary encoders have been acting very weird in the last few days. They are now disabled when the FakeRotaryEncoders flag is true , which has solved intermittent blocking and crashes. The crashes did not occur consistently or even at a particular point in the code. Sometimes the Arduino would randomly not exit the jiggling loop, for example. This is incredibly odd, as no I2C logic is run during that loop, nor by the stepping interrupt. Perhaps the rotary encoder chip is bad and causes undefined behaviour on the Arduino due to not acting as a nice I2C slave. Perhaps the Arduino has somehow been damaged, though hopefully this would not cause such inconsistent, intermittent failures. This may also be tangentially related to the fact that the rotary encoder does not experience a magnetic field of ideal strength. This is due to the proximity of the diametrically magnetised coin magnet to the ferromagnetic ball bearing. This distance should be increased in a later hardware revision (very easy and unintrusive, just didn't have the time). This, however, should also not result in the behaviour I saw. It is also possible that this stems from a bug in the code of the rotary encoder library (AMS_5600), which I did not fully investigate. It could also be due to an error in the I2C multiplexer used. Since the Due has two I2C interfaces, the multiplexer is not strictly needed, though some modification of the AMS_5600 library would be needed to use both I2C interfaces.","title":"Rotary encoders"},{"location":"articles/handover_v1/#random-arduino-resets","text":"I am getting random Arduino resets and I cannot for the life of me figure out why. The latest theory is that the noise from the wires going to the stepper motors is causing overvoltages on some logic lines that will then trigger a reset. This could be tested by disabling the motor power supply and running the experiment for a few hours. If no resets occur, it is likely a problem related to electrical noise. I haven't had time to try this, so please go ahead and try. It is some very long hanging fruit!","title":"Random Arduino Resets"},{"location":"articles/handover_v1/#learning-on-the-physical-system","text":"I have not yet been able to get significant learning using the experimental setup. I believe as of today (my last day), the experiment will now run for extended periods of time (after disabling the rotary encoders), and so it may learn over the coming weekend. It could also be that the PPO/A2C algorithms used are not pleased with the inconsistent step intervals (these arise from learning causing the thread to block for tens of millisecs, as well as delays in the USB protocol and on the host computer). From Tensorboard it is clear that the correct rewards are being calculated and actions are being taken, though these do not seem to lead to improved behaviour over time - perhaps I simply haven't given it enough time yet. I don't have any obvious explanations for why the learning is not better than it currently is. I may have missed a critical bug somewhere, but since rewards and actions are both working as expected, I don't think this will be the case. Perhaps model-free reinforcement learning is just very difficult, particularly on noisy, physical systems? It could also be that the hyperparameters need significant tuning in order to get stable learning to occur.","title":"Learning on the physical system"},{"location":"articles/handover_v1/#two-carriage-configuration","text":"Most of the code is set up to handle two carriages already, though currently the limit finding/checking routines would need to be updated to work for a two-carriage system as well. The hardware and electronics are fully compatible with both a one- and two-carriage configuration. Likely there is also some code on the environment (not agent) level in the Commander that would need fine-tuning. The two-carriage configuration should only be persued once the one-carriage configuration is fully working and finalised.","title":"Two-carriage configuration"},{"location":"articles/handover_v1/#what-could-be-improved","text":"","title":"What could be improved"},{"location":"articles/handover_v1/#new-microcontroller","text":"Dealing with the Arduino Due has been somewhat frustrating, and while changing to a different one at this stage would require some effort, I believe that it would be worth it. Problematically the Arduino Due has not seen significant work done on it's core software in many years and the documentation for the board is even poorer than the already poor documentation for 8-bit AVR Arduino boards. I changed away from the Arduino build system fairly early on after getting frustrated with the terrible usability problems of it as well as its practically non-existant support for multiple files. Instead, the project now uses platform.io , which is orders of magnitude more reliable, intuitive, and well-designed. Ultimately, I think the same should be done for the Arduino. Since CartER aims to be easy to set up for others and should rely on off-the-shelf parts, I think the STM Nucleo-144 could be a very powerful option: Built-in debugger 400 MHz clock speed Ethernet support Higher baudrates possible (limited to 115200 on Due due to bug in Arduino Core\ud83d\ude1e) Many pins broken out Cheap Readily available mbed -compatible When doing this, it would be very worthwhile to switch away from the Arduino Wiring framework entirely, as this is incredibly poorly documented and only ever intended for hobbyist use. Arduino was groundbreaking in that it made access to hobby-level microcontrollers easy and open, but since then Arm has developed mbed which is also open and is infinitely more polished. mbed even has a full RTOS version, which could be very useful for this project. This would likely make it possible to reduce fiddliness around the I2C connection with the rotary encoder, as well as a generally nicer code layout. mbed + STM Nucleo-144 is supported in platform.io . There is an existing library for modern TMC stepper drivers for mbed and writing a quick library for the rotary encoder should not take long.","title":"New Microcontroller"},{"location":"articles/handover_v1/#new-stepper-drivers","text":"Rather than relying on the rather old TMC26X drivers, these should be changed for TMC2208/TMC2209 drivers. These have far better support and documentation. They are cheap and more readily available than the TMC26X drivers, which are strictly inferior.","title":"New stepper drivers"},{"location":"articles/handover_v1/#real-time-or-close-to-it-networking","text":"Using Serial-over-USB is far from ideal and seems to give a 4ms round-trip time in the best of cases (See: Serial ). Since the STM board has Ethernet capability built in, it might be useful to use Ethernet for networking. This would allow far lower latency and much more reliable communication than the current implementation. A real-time ethernet system like EtherCAT could be used if timing becomes critical, though this will likely be overkill. Alternatively a proper serial connection could be used. This would require a simple level-shifting board on the controller-side and a serial board to be installed in the computer. Both of these options are cheap and readily available. Arguably Ethernet is more commonly found, though configuration can also be more complicated.","title":"Real-time (or close to it) Networking"},{"location":"articles/handover_v1/#getting-set-up","text":"A good way of working is using VSCode with the Remote: SSH functionality. That way, you get to develop on the powerful workstation and run experiments and simulations on it directly, but while still using your own IDE configuration and the familiar keyboard of your laptop. These lines, for example, were written in the rest area upstairs, but on the workstation downstairs in the Physics Lab through seamless integration via SSH and VSCode. More advice on how to get set up can be found in the other sections of the documentation.","title":"Getting set up"},{"location":"articles/introducing_carter/","text":"Introducing CartER \u00b6 CartER is a physical experimental setup for the development and exploration of reinforcement learning algorithms in a reproducable, accessible way. The OpenAI Gym and PettingZoo projects have provided a standardised set of environments for use in single and multiagent reinforcement learning, which has enabled the academic community to use a consistent, reproducable environment across different papers, research groups, and organisations. CartER enables the user to try out reinforcement learning algorithms (mainly model-free ones) on a physical system as well as a more involved cartpole environment than the one found in the OpenAI Gym . Why do we care about physical systems? \u00b6 Physical systems are inherently noisy and introduce a variety of random and systematic errors that prove challenging for to accurately and reliably overcome using traditional methods. Agents trained in such an environment, however, can be expected to be more resillient towards errors in the observation and action spaces. CartER could thus be a valuable tool for reinforcement learning researchers hoping to battle-test their algorithms in a physical environment where resillience against latency and variable step intervals pose new challenges. Further, a physical system imposes constraints on inference and learning times, as the dynamics of the system will continue to act as the model is performing blocking operations. As such, one might expect off-policy models may outperform on-policy models in this domain, as inference and learning can more easily be separated, thus allowing for a tighter action-observation loop separate to the learning routine. Why do we care about CartER? \u00b6 CartER is open-source, cheap, and made of readily available parts. Thus, it lives up to many of the requirements of a standard benchmark, which will be of significant importance as the field of model-free reinforcement learning will start to more thoroughly explore viable implementations in the area of physical systems. Perspectives \u00b6 Studying physical systems using reinforcement learning has a number of potentially profitable perspectives. Symbolic Regression \u00b6 Combined with symbolic regression/optimisation (cf. DSO ) it may be possible to recover the equations of motion for a given physical system. While the cartpole system is well-studied and the governing equations already known, demonstrating symbolic regression using CartER could give confidence to projects hoping to recover information from more complicated systems where traditional methods may be untenable or fail entirely. Further, CartER could be used in a coupled two-carriage configuration to study symbolic regression in multiagent environments or to demonstrate how reinforcement learning could be a faster, more robust way to recover information about coupled mechanical systems.","title":"Introducing CartER"},{"location":"articles/introducing_carter/#introducing-carter","text":"CartER is a physical experimental setup for the development and exploration of reinforcement learning algorithms in a reproducable, accessible way. The OpenAI Gym and PettingZoo projects have provided a standardised set of environments for use in single and multiagent reinforcement learning, which has enabled the academic community to use a consistent, reproducable environment across different papers, research groups, and organisations. CartER enables the user to try out reinforcement learning algorithms (mainly model-free ones) on a physical system as well as a more involved cartpole environment than the one found in the OpenAI Gym .","title":"Introducing CartER"},{"location":"articles/introducing_carter/#why-do-we-care-about-physical-systems","text":"Physical systems are inherently noisy and introduce a variety of random and systematic errors that prove challenging for to accurately and reliably overcome using traditional methods. Agents trained in such an environment, however, can be expected to be more resillient towards errors in the observation and action spaces. CartER could thus be a valuable tool for reinforcement learning researchers hoping to battle-test their algorithms in a physical environment where resillience against latency and variable step intervals pose new challenges. Further, a physical system imposes constraints on inference and learning times, as the dynamics of the system will continue to act as the model is performing blocking operations. As such, one might expect off-policy models may outperform on-policy models in this domain, as inference and learning can more easily be separated, thus allowing for a tighter action-observation loop separate to the learning routine.","title":"Why do we care about physical systems?"},{"location":"articles/introducing_carter/#why-do-we-care-about-carter","text":"CartER is open-source, cheap, and made of readily available parts. Thus, it lives up to many of the requirements of a standard benchmark, which will be of significant importance as the field of model-free reinforcement learning will start to more thoroughly explore viable implementations in the area of physical systems.","title":"Why do we care about CartER?"},{"location":"articles/introducing_carter/#perspectives","text":"Studying physical systems using reinforcement learning has a number of potentially profitable perspectives.","title":"Perspectives"},{"location":"articles/introducing_carter/#symbolic-regression","text":"Combined with symbolic regression/optimisation (cf. DSO ) it may be possible to recover the equations of motion for a given physical system. While the cartpole system is well-studied and the governing equations already known, demonstrating symbolic regression using CartER could give confidence to projects hoping to recover information from more complicated systems where traditional methods may be untenable or fail entirely. Further, CartER could be used in a coupled two-carriage configuration to study symbolic regression in multiagent environments or to demonstrate how reinforcement learning could be a faster, more robust way to recover information about coupled mechanical systems.","title":"Symbolic Regression"},{"location":"building/","text":"Introduction \u00b6 TODO This section has not been written yet. It will be written in the future once the project has reached a more mature state.","title":"Introduction"},{"location":"building/#introduction","text":"TODO This section has not been written yet. It will be written in the future once the project has reached a more mature state.","title":"Introduction"},{"location":"building/bom/","text":"Bill of Materials \u00b6 TODO This page is not done, but will be completed in the future once the hardware implementation is finalised. Item Category Qty \u2248 Price Link Arduino Due Electronics 1 30 \u00a3 USB-B Micro -> USB A Cable Misc. 1 2 \u00a3","title":"Bill of Materials"},{"location":"building/bom/#bill-of-materials","text":"TODO This page is not done, but will be completed in the future once the hardware implementation is finalised. Item Category Qty \u2248 Price Link Arduino Due Electronics 1 30 \u00a3 USB-B Micro -> USB A Cable Misc. 1 2 \u00a3","title":"Bill of Materials"},{"location":"development/","text":"Introduction \u00b6 The development documentation is not complete, but does contain some useful pointers on how to set up the system as well as discussions of some common issues around serial connections, steppers, and networking. Project layout \u00b6 mkdocs.yml # Documentation configuration file. docs/** # Documentation files. pyproject.toml # Poetry project configuration. commander/** # Commander code. controller/ platformio.ini # Platform.io project configuration. ** # Controller code. notebooks/** # Notebooks that are helpful in debugging or studying experiment.","title":"Introduction"},{"location":"development/#introduction","text":"The development documentation is not complete, but does contain some useful pointers on how to set up the system as well as discussions of some common issues around serial connections, steppers, and networking.","title":"Introduction"},{"location":"development/#project-layout","text":"mkdocs.yml # Documentation configuration file. docs/** # Documentation files. pyproject.toml # Poetry project configuration. commander/** # Commander code. controller/ platformio.ini # Platform.io project configuration. ** # Controller code. notebooks/** # Notebooks that are helpful in debugging or studying experiment.","title":"Project layout"},{"location":"development/cad/","text":"CAD Files \u00b6 The CAD has been done in Autodesk Fusion 360, which is unfortunately not very easy to share in an open-source friendly manner. Once downloading files from the cloud in bulk is no longer broken, CAD dumps will be available on the GitHub page. If you are interested in the project, please reach out to jk782@cam.ac.uk in order to get access to the CAD files through Autodesk Cloud. The main assembly file can be found here: Full Construction","title":"CAD Files"},{"location":"development/cad/#cad-files","text":"The CAD has been done in Autodesk Fusion 360, which is unfortunately not very easy to share in an open-source friendly manner. Once downloading files from the cloud in bulk is no longer broken, CAD dumps will be available on the GitHub page. If you are interested in the project, please reach out to jk782@cam.ac.uk in order to get access to the CAD files through Autodesk Cloud. The main assembly file can be found here: Full Construction","title":"CAD Files"},{"location":"development/cli/","text":"Command-line interface \u00b6 The Commander provides a basic commands for running simulations, though these are still will likely need to be expanded upon for further experimentation. The command-line interface is made available as carter ... . Note that this requires the poetry virtual environment to be activated.","title":"Command-line interface"},{"location":"development/cli/#command-line-interface","text":"The Commander provides a basic commands for running simulations, though these are still will likely need to be expanded upon for further experimentation. The command-line interface is made available as carter ... . Note that this requires the poetry virtual environment to be activated.","title":"Command-line interface"},{"location":"development/diagram/","text":"Diagrammatic overview \u00b6 Below is a diagrammatic overview of CartER.","title":"Diagrammatic overview"},{"location":"development/diagram/#diagrammatic-overview","text":"Below is a diagrammatic overview of CartER.","title":"Diagrammatic overview"},{"location":"development/further_work/","text":"Further Work (To-do) \u00b6 Increase distance between magnet and ball bearing \u00b6 While the current setup does work fairly reliably, the distance between the diametrically magnetised magnet and the ferromagnetic housing of the ball bearing on each cart would ideally be increased to allow for higher field strengths at the rotary encoder chip. On start-up the system prints information about the strength of the magnet and currently reports it as below the ideal strength.","title":"Further Work (To-do)"},{"location":"development/further_work/#further-work-to-do","text":"","title":"Further Work (To-do)"},{"location":"development/further_work/#increase-distance-between-magnet-and-ball-bearing","text":"While the current setup does work fairly reliably, the distance between the diametrically magnetised magnet and the ferromagnetic housing of the ball bearing on each cart would ideally be increased to allow for higher field strengths at the rotary encoder chip. On start-up the system prints information about the strength of the magnet and currently reports it as below the ideal strength.","title":"Increase distance between magnet and ball bearing"},{"location":"development/installation/","text":"Installation \u00b6 This is an installation guide for getting setup with the software side of things. It assumes: - Linux Environment - Basic knowledge of terminal environment - Visual Studio Code installed - Git installed - Python 3.9+ installed 1 - Clone project \u00b6 git clone https://github.com/JeppeKlitgaard/CartER.git 2 - Platform.io \u00b6 Open the CartER folder in vscode . Install platformio if not already installed. If on Linux make sure to follow PlatformIO guide to udev setup Add the CartER/controller/ folder to vscode ( Workspaces: Add Folder to Workspace... ) Restart vscode Run pio run in a Platform IO terminal ( PlatformIO: New Terminal ) 3 - Poetry \u00b6 Install Poetry Configure poetry to use local venv by running poetry config virtualenvs.in-project true Run poetry install in CartER/ directory Virtual Environments The rest of this guide assumes you are in a terminal with the project virtualenv activated. You can activate the virtualenv by running poetry shell in the CartER/ directory. 4 - Test \u00b6 Now test that you can: - Build the controller source using: PlatformIO: Build in vscode . - Upload to the microcontroller using PlatformIO: Upload in vscode . - Perform an experiment using carter experiment in a virtualenv'd shell.","title":"Installation"},{"location":"development/installation/#installation","text":"This is an installation guide for getting setup with the software side of things. It assumes: - Linux Environment - Basic knowledge of terminal environment - Visual Studio Code installed - Git installed - Python 3.9+ installed","title":"Installation"},{"location":"development/installation/#1-clone-project","text":"git clone https://github.com/JeppeKlitgaard/CartER.git","title":"1 - Clone project"},{"location":"development/installation/#2-platformio","text":"Open the CartER folder in vscode . Install platformio if not already installed. If on Linux make sure to follow PlatformIO guide to udev setup Add the CartER/controller/ folder to vscode ( Workspaces: Add Folder to Workspace... ) Restart vscode Run pio run in a Platform IO terminal ( PlatformIO: New Terminal )","title":"2 - Platform.io"},{"location":"development/installation/#3-poetry","text":"Install Poetry Configure poetry to use local venv by running poetry config virtualenvs.in-project true Run poetry install in CartER/ directory Virtual Environments The rest of this guide assumes you are in a terminal with the project virtualenv activated. You can activate the virtualenv by running poetry shell in the CartER/ directory.","title":"3 - Poetry"},{"location":"development/installation/#4-test","text":"Now test that you can: - Build the controller source using: PlatformIO: Build in vscode . - Upload to the microcontroller using PlatformIO: Upload in vscode . - Perform an experiment using carter experiment in a virtualenv'd shell.","title":"4 - Test"},{"location":"development/protocol/","text":"Protocol \u00b6 The protocol used for serial communication is implemented using POD's (Plain Old Datatypes) and serialised to little-endian binary before being sent back and forth over a serial interface. Using a proper serial-connection rather than rely on the Serial-over-USB that comes standard with the Arduino Due is recommended to avoid the \u2248 4ms round-trip time in USB packet delivery. Implementation - Commander \u00b6 The protocol is best understood by reading through the protocol.py file on the commander. It should be fairly easily understood by those familiar with Python. It uses the standard library struct to pack and unpack data. Implementation - Controller \u00b6 The protocol must match the one implemented on the commander exactly, as any difference in packet lengths will lead to future misalignment that cannot easily be corrected for. A struct -like library is also used on the controller to allow for easy matching between the controller and commander protocol implementations. Packet overview \u00b6 ID (byte) ID (ASCII) Packet Direction (Controller \u2194 Commander) Fields Comment 0x00 NUL NullPacket N/A id Does nothing 0x3F ? UnknownPacket N/A id An unknown packet was found 0x23 # DebugPacket \u27f6 id , msg Debug messages 0x7E ~ InfoPacket \u27f6 id , msg Info messages 0x21 ! ErrorPacket \u27f6 id , msg Error messages 0x70 p PingPacket \u27f7 id , timestamp Other end should respond with a pong 0x50 P PongPacket \u27f7 id , timestamp Response to ping 0x24 $ RequestDebugInfoPacket \u27f5 id Requests debug information from controller 0x78 x SetPositionPacket \u27f5 id , operation , cart_id , value Sets relative or absolute position 0x58 X GetPositionPacket \u27f6 id UNUSED . Gets position 0x76 v SetVelocityPacket \u27f5 id , operation , cart_id , value Sets relative or absolute maximum velocity 0x56 V GetVelocityPacket \u27f6 id UNUSED . Gets maximum velocity 0x7C | FindLimitsPacket \u27f7 id Instructs controller to perform limit finding routine 0x2F / CheckLimitPacket \u27f7 id Instructs controller to perform limit checking routine 0xA7 \u00a7 DoJigglePacket \u27f7 id Instructs controller to perform a jiggle routine 0x40 @ ObservationPacket \u27f6 id , timestamp_micros , cart_id , position_steps , angle Observed state 0x02 STX ExperimentStartPacket \u27f7 id , timestamp_micros Observed state 0x03 ETX ExperimentEndPacket \u27f7 id Observed state","title":"Protocol"},{"location":"development/protocol/#protocol","text":"The protocol used for serial communication is implemented using POD's (Plain Old Datatypes) and serialised to little-endian binary before being sent back and forth over a serial interface. Using a proper serial-connection rather than rely on the Serial-over-USB that comes standard with the Arduino Due is recommended to avoid the \u2248 4ms round-trip time in USB packet delivery.","title":"Protocol"},{"location":"development/protocol/#implementation-commander","text":"The protocol is best understood by reading through the protocol.py file on the commander. It should be fairly easily understood by those familiar with Python. It uses the standard library struct to pack and unpack data.","title":"Implementation - Commander"},{"location":"development/protocol/#implementation-controller","text":"The protocol must match the one implemented on the commander exactly, as any difference in packet lengths will lead to future misalignment that cannot easily be corrected for. A struct -like library is also used on the controller to allow for easy matching between the controller and commander protocol implementations.","title":"Implementation - Controller"},{"location":"development/protocol/#packet-overview","text":"ID (byte) ID (ASCII) Packet Direction (Controller \u2194 Commander) Fields Comment 0x00 NUL NullPacket N/A id Does nothing 0x3F ? UnknownPacket N/A id An unknown packet was found 0x23 # DebugPacket \u27f6 id , msg Debug messages 0x7E ~ InfoPacket \u27f6 id , msg Info messages 0x21 ! ErrorPacket \u27f6 id , msg Error messages 0x70 p PingPacket \u27f7 id , timestamp Other end should respond with a pong 0x50 P PongPacket \u27f7 id , timestamp Response to ping 0x24 $ RequestDebugInfoPacket \u27f5 id Requests debug information from controller 0x78 x SetPositionPacket \u27f5 id , operation , cart_id , value Sets relative or absolute position 0x58 X GetPositionPacket \u27f6 id UNUSED . Gets position 0x76 v SetVelocityPacket \u27f5 id , operation , cart_id , value Sets relative or absolute maximum velocity 0x56 V GetVelocityPacket \u27f6 id UNUSED . Gets maximum velocity 0x7C | FindLimitsPacket \u27f7 id Instructs controller to perform limit finding routine 0x2F / CheckLimitPacket \u27f7 id Instructs controller to perform limit checking routine 0xA7 \u00a7 DoJigglePacket \u27f7 id Instructs controller to perform a jiggle routine 0x40 @ ObservationPacket \u27f6 id , timestamp_micros , cart_id , position_steps , angle Observed state 0x02 STX ExperimentStartPacket \u27f7 id , timestamp_micros Observed state 0x03 ETX ExperimentEndPacket \u27f7 id Observed state","title":"Packet overview"},{"location":"development/serial/","text":"Serial \u00b6 The communication between the controller and the commander is done over a serial interface. This allows for real-time communication, though only when proper hardware implementations are in place on both ends. In most cases, serial peripherals for a PC and for the Arduino will not be available, at which point it makes sense to fall back to the Serial-over-USB capability of the Arduino Due. Note that this introduces latency due to the finite frame exchange interval of the USB protocol. In practice this means a round-trip time of \u2248 4ms when using Serial-over-USB. Round-trip time \u00b6 The round-trip time is defined as the time from sending a ping until the corresponding pong has been received. Below is a measurement of \\(5 \\cdot 10^4\\) ping-pong episodes. The vast majority of episodes seem to fall around the \\(4\\, \\text{ms}\\) mark. Protocol alignment \u00b6 Since the Protocol operates at a byte-level, there is no easy way to realign to a packet ID if misalignment ever occurs. For this reason, a reliable serial connection is critical. Ensure that an appropriate baudrate is used. See also: Noise suppression Buffer size \u00b6 By default the serial buffer size of the Arduino is a measly 64 bytes, which means that it will quickly overflow and cause misalignment if not read from sufficiently often. This can be mitigated by ensuring that the Commander empties the serial buffer often, and further mitigated by increasing the buffer size using the SERIAL_BUFFER_SIZE definition. This can be done using platform.io in the platformio.ini file with a build flag -DSERIAL_BUFFER_SIZE=<buffer size> Noise suppression \u00b6 Currently without any noise suppression the experimental system seems to get misaligned very rarely, but this can be an issue if running the system for multiple hours or days. While an ACK/NACK-style protocol would arguably be the most robust choice, this would add a lot of complexity to the protocol and thus hasn't been implemented. Instead the Commander will request a realignment sequence to be sent by the Controller if it experiences misalignment. This does lead to some packet loss since any bytes prior to the realignment sequence will be flushed and are not resent. Given the rarity of noise, this approach will generally be robust enough to to have very long running experiments. Artificial noise can be added for testing using the constants defined in PacketSender.h of the Controller.","title":"Serial"},{"location":"development/serial/#serial","text":"The communication between the controller and the commander is done over a serial interface. This allows for real-time communication, though only when proper hardware implementations are in place on both ends. In most cases, serial peripherals for a PC and for the Arduino will not be available, at which point it makes sense to fall back to the Serial-over-USB capability of the Arduino Due. Note that this introduces latency due to the finite frame exchange interval of the USB protocol. In practice this means a round-trip time of \u2248 4ms when using Serial-over-USB.","title":"Serial"},{"location":"development/serial/#round-trip-time","text":"The round-trip time is defined as the time from sending a ping until the corresponding pong has been received. Below is a measurement of \\(5 \\cdot 10^4\\) ping-pong episodes. The vast majority of episodes seem to fall around the \\(4\\, \\text{ms}\\) mark.","title":"Round-trip time"},{"location":"development/serial/#protocol-alignment","text":"Since the Protocol operates at a byte-level, there is no easy way to realign to a packet ID if misalignment ever occurs. For this reason, a reliable serial connection is critical. Ensure that an appropriate baudrate is used. See also: Noise suppression","title":"Protocol alignment"},{"location":"development/serial/#buffer-size","text":"By default the serial buffer size of the Arduino is a measly 64 bytes, which means that it will quickly overflow and cause misalignment if not read from sufficiently often. This can be mitigated by ensuring that the Commander empties the serial buffer often, and further mitigated by increasing the buffer size using the SERIAL_BUFFER_SIZE definition. This can be done using platform.io in the platformio.ini file with a build flag -DSERIAL_BUFFER_SIZE=<buffer size>","title":"Buffer size"},{"location":"development/serial/#noise-suppression","text":"Currently without any noise suppression the experimental system seems to get misaligned very rarely, but this can be an issue if running the system for multiple hours or days. While an ACK/NACK-style protocol would arguably be the most robust choice, this would add a lot of complexity to the protocol and thus hasn't been implemented. Instead the Commander will request a realignment sequence to be sent by the Controller if it experiences misalignment. This does lead to some packet loss since any bytes prior to the realignment sequence will be flushed and are not resent. Given the rarity of noise, this approach will generally be robust enough to to have very long running experiments. Artificial noise can be added for testing using the constants defined in PacketSender.h of the Controller.","title":"Noise suppression"},{"location":"development/stepper/","text":"Steppers \u00b6 Having the appropriate pulse rate is critical when driving the steppers in a dir/step mode. From the datasheet of, for example, the RS PRO 5350479 stepper motor, we can see that a pulse rate of \\(\u2248 5\\ \\text{kHz}\\) would be ideal if torque is the main concern. In order to achieve a reliable pulse rate, we can utilise timer interrupts , which is done using the tc_lib library for Arduino SAM. If you use a different board, you may need to use a different library or implement the timer interrupts by hand . Thus we which to have a timer period of: \\[ T = f^{-1} = \\frac{1}{5000} = 2 \u22c5 10^{-4} s = 2 \u22c5 10^{4} \\ \\qty[10^{-8}\\, s] \\]","title":"Steppers"},{"location":"development/stepper/#steppers","text":"Having the appropriate pulse rate is critical when driving the steppers in a dir/step mode. From the datasheet of, for example, the RS PRO 5350479 stepper motor, we can see that a pulse rate of \\(\u2248 5\\ \\text{kHz}\\) would be ideal if torque is the main concern. In order to achieve a reliable pulse rate, we can utilise timer interrupts , which is done using the tc_lib library for Arduino SAM. If you use a different board, you may need to use a different library or implement the timer interrupts by hand . Thus we which to have a timer period of: \\[ T = f^{-1} = \\frac{1}{5000} = 2 \u22c5 10^{-4} s = 2 \u22c5 10^{4} \\ \\qty[10^{-8}\\, s] \\]","title":"Steppers"},{"location":"usage/","text":"Introduction \u00b6 This section of the documentation contains usage guides on how to set up CartpoleML for use in machine learning projects. TODO This part of the documentation has not yet been written.","title":"Introduction"},{"location":"usage/#introduction","text":"This section of the documentation contains usage guides on how to set up CartpoleML for use in machine learning projects. TODO This part of the documentation has not yet been written.","title":"Introduction"},{"location":"videos/","text":"Introduction \u00b6 The part of the documentation hosts a variety of videos demonstrating some of the possibilities of the project","title":"Introduction"},{"location":"videos/#introduction","text":"The part of the documentation hosts a variety of videos demonstrating some of the possibilities of the project","title":"Introduction"},{"location":"videos/movements_using_ppo/","text":"Movements using PPO algorithm \u00b6 This video demonstrates carriage movements in a single-carriage configuration using the PPO model implementation of stable-baselines3 .","title":"Movements using PPO algorithm"},{"location":"videos/movements_using_ppo/#movements-using-ppo-algorithm","text":"This video demonstrates carriage movements in a single-carriage configuration using the PPO model implementation of stable-baselines3 .","title":"Movements using PPO algorithm"}]}